# 布隆过滤器

虽然我们现在有了索引和 `mmap`，但查询一个 Key 仍然需要以下两步：

1. **查索引**（在内存中进行二分查找，很快）。
2. **读数据块**（根据索引定位到 Data Block，进行解析）。

**问题出在第二步。**

### 1. 为什么“二分查找”还不够？

想象一下，如果你的 NovaKV 运行了一段时间，磁盘上有 100 个 SSTable 文件。当用户查询一个**不存在**的 `key_888` 时：

- 你的程序会遍历这 100 个文件。
- 每个文件都要通过 `std::lower_bound` 查一遍索引。
- **最糟糕的是**：索引可能会告诉你：“`key_888` 应该在第 5 个 Block 里”。于是你的程序兴冲冲地去解析这个 Block，结果扫完 4KB 发现——**查无此人**。

**结论**：为了确认一个 Key “不存在”，你竟然做了 100 次二分查找，甚至可能触发了多次磁盘 I/O（如果 Page Cache 没命中的话）。这种现象叫 **I/O 放大**。

------

### 2. 布隆过滤器（Bloom Filter）：存不存在的“算命先生”

布隆过滤器的核心价值不是告诉你“它在哪里”，而是**高效率地告诉你“它肯定不在那儿”**。

它是一串极小的二进制位（Bitset）。当你在 `SSTableBuilder` 写入数据时，顺便把 Key 丢给几个哈希函数，在位图上打几个点。

- **它说“不在”**：那这个 Key 就 **100% 绝对不在** 这个文件里。你可以直接跳过这个文件，连索引都不用看！
- **它说“在”**：它有极小的概率（比如 1%）是在“撒谎”（假阳性）。这时候你再去走正常的索引查询逻辑。

------

### 3. 加入布隆过滤器后的 `Get` 流程

对比一下两者的效率差距：

| **步骤**   | **现在的 Get (无过滤)**    | **加入布隆过滤器后的 Get**        |
| ---------- | -------------------------- | --------------------------------- |
| **第一步** | 查索引 (Binary Search)     | **问过滤器：Key 在吗？**          |
| **第二步** | **解析 Data Block (最慢)** | 若不在，直接返回 False (瞬间结束) |
| **第三步** | 确认 Key 不存在            | 若可能在，才查索引并解析 Block    |

**质变点**：对于大量查询“不存在的 Key”的情况，布隆过滤器能挡掉 **99%** 的无效磁盘访问和 CPU 解析开销。