# 布隆过滤器

## 有什么用？

虽然我们现在有了索引和 `mmap`，但查询一个 Key 仍然需要以下两步：

1. **查索引**（在内存中进行二分查找，很快）。
2. **读数据块**（根据索引定位到 Data Block，进行解析）。

**问题出在第二步。**

### 1. 为什么“二分查找”还不够？

想象一下，如果你的 NovaKV 运行了一段时间，磁盘上有 100 个 SSTable 文件。当用户查询一个**不存在**的 `key_888` 时：

- 你的程序会遍历这 100 个文件。
- 每个文件都要通过 `std::lower_bound` 查一遍索引。
- **最糟糕的是**：索引可能会告诉你：“`key_888` 应该在第 5 个 Block 里”。于是你的程序兴冲冲地去解析这个 Block，结果扫完 4KB 发现——**查无此人**。

**结论**：为了确认一个 Key “不存在”，你竟然做了 100 次二分查找，甚至可能触发了多次磁盘 I/O（如果 Page Cache 没命中的话）。这种现象叫 **I/O 放大**。

------

### 2. 布隆过滤器（Bloom Filter）：存不存在的“算命先生”

布隆过滤器的核心价值不是告诉你“它在哪里”，而是**高效率地告诉你“它肯定不在那儿”**。

它是一串极小的二进制位（Bitset）。当你在 `SSTableBuilder` 写入数据时，顺便把 Key 丢给几个哈希函数，在位图上打几个点。

- **它说“不在”**：那这个 Key 就 **100% 绝对不在** 这个文件里。你可以直接跳过这个文件，连索引都不用看！
- **它说“在”**：它有极小的概率（比如 1%）是在“撒谎”（假阳性）。这时候你再去走正常的索引查询逻辑。

------

### 3. 加入布隆过滤器后的 `Get` 流程

对比一下两者的效率差距：

| **步骤**   | **现在的 Get (无过滤)**    | **加入布隆过滤器后的 Get**        |
| ---------- | -------------------------- | --------------------------------- |
| **第一步** | 查索引 (Binary Search)     | **问过滤器：Key 在吗？**          |
| **第二步** | **解析 Data Block (最慢)** | 若不在，直接返回 False (瞬间结束) |
| **第三步** | 确认 Key 不存在            | 若可能在，才查索引并解析 Block    |

**质变点**：对于大量查询“不存在的 Key”的情况，布隆过滤器能挡掉 **99%** 的无效磁盘访问和 CPU 解析开销。



## 实现原理

### 1. 核心矛盾：为什么需要它？

想象你正在做一个爬虫，已经爬取了 10 亿个 URL。现在又发现了一个新 URL，你怎么知道它是否已经被爬过了？

- **方案 A（哈希表）**：把 10 亿个 URL 存进 `std::unordered_set`。
  - *问题*：10 亿个字符串，即使每个 20 字节，也要占用 20GB+ 内存。太贵了。
- **方案 B（位图 Bitmap）**：如果 URL 对应的是连续整数，可以用位图。
  - *问题*：URL 是字符串，分布极不均匀，位图无法直接处理。
- **方案 C（布隆过滤器）**：不需要存储原始 URL，只存储“痕迹”。

------

### 2. 实现原理：染色与查色

布隆过滤器的核心是一个**大型二进制数组（Bitset）**和 **$k$ 个互相独立的哈希函数**。

#### 写入过程（染色）

当你要把一个元素（比如 `key_001`）存入布隆过滤器时：

1. 分别用 $k$ 个哈希函数对 `key_001` 进行计算，得到 $k$ 个哈希值。
2. 将这些哈希值对数组长度取模，得到 $k$ 个索引位置。
3. **将位数组中对应的这些位置全部设为 1**。

#### 查询过程（查色）

当你想知道 `key_002` 是否在集合中时：

1. 同样用那 $k$ 个哈希函数算出 $k$ 个位置。
2. **检查这 $k$ 个位置的值**：
   - **只要有一个位置是 0**：那么 `key_002` **绝对（100%）不在**集合中！因为如果它在，那些位置当初一定会被染成 1。
   - **如果全部位置都是 1**：那么 `key_002` **可能在**集合中。

------

### 3. 灵魂拷问：为什么是“可能在”？

这就是布隆过滤器的**假阳性（False Positive）**。

如上图所示，如果 `key_A` 染红了位置 {1, 3, 5}，`key_B` 染红了位置 {2, 4, 6}。

现在来了一个从未见过的 `key_C`，它的哈希位置恰好是 {1, 4, 5}。

此时你会发现这三个位置全是 1，于是布隆过滤器会告诉你：`key_C` 好像在里面。

这就是“假阳性”——它虽然没见过这个元素，但因为位置被别人占了，它产生了误报。

------

### 4. 关键特性与数学权衡（面试加分项）

- **空间利用率极高**：它不存储原始数据。在假阳性率为 1% 的情况下，每个元素平均只需要约 9.6 个比特（bits）。
- **查询速度极快**：只有 $k$ 次简单的哈希计算和位查找。
- **不支持删除**：这是它最大的缺点。因为你不能把某个位置从 1 改回 0，这可能会影响到其他哈希到该位置的元素。
- **三个参数的博弈**：
  1. **$m$（位数组长度）**：数组越大，冲突越少，精度越高。
  2. **$n$（元素个数）**：元素越多，数组越“红”，精度越低。
  3. **$k$（哈希函数个数）**：$k$ 太小区分度不够；$k$ 太大则数组填满得快。

------

### 5. 在 NovaKV 中的应用场景

在我们的 SSTable 中，布隆过滤器的作用是 **“拒绝不必要的磁盘访问”**：

1. 用户查询 `Get("bad_key")`。
2. 先查内存中的布隆过滤器数据（这一步非常快，完全在 CPU/缓存中完成）。
3. 布隆过滤器返回 `false`（表示绝对不在）。
4. **NovaKV 立即返回结果，不再去查磁盘索引，不再去解析 Data Block。**

这种“一票否决权”在大规模数据查询中，能让性能产生质的飞跃。

## 如何应用？

| **阶段**      | **角色**         | **动作**                                                     |
| ------------- | ---------------- | ------------------------------------------------------------ |
| **生产阶段**  | `SSTableBuilder` | 1. 收集所有 `Add` 的 Key。 2. **(核心)** 计算哈希，染红位图。 3. 将位图数据写入文件末尾。 |
| **传输/存储** | 磁盘文件         | 此时文件里多了一段二进制数据：**Filter Block**。             |
| **消费阶段**  | `SSTableReader`  | 1. `Open` 时把 Filter Block 映射到内存。 2. `Get` 时先拿着 Key 去比对位图。 3. 判定不通过直接拦截，判定通过才去翻书（查索引）。 |