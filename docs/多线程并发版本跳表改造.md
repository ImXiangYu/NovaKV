# 多线程并发版本跳表改造

## 方案

互斥同步+原子性读写分离，即写时加锁，读无锁

## 具体实现

1. 将 `SkipList::Node` 里的指针向量改为原子类型 `std::atomic`。即`std::vector<std::atomic<Node*>>` 



## 为什么要用`atomic` 

这是一个非常硬核的底层问题，触及了**多处理器架构**和**编译器优化**的本质。

在多线程环境下，如果你直接使用 `Node* next` 而不是 `std::atomic<Node*>`，主要面临以下三大风险：

### 1. 指针撕裂 (Pointer Tearing)

在现代 64 位系统上，指针大小是 8 字节。虽然 CPU 读写对齐的 8 字节数据通常是原子性的，但 **C++ 标准并不保证这一点**。

- **场景**：假设线程 A 正在更新一个节点的指针。
- **物理过程**：在某些老旧架构、非对齐内存访问或特定的编译器行为下，8 字节的指针写入可能被拆分为两次 4 字节的操作。
- **后果**：线程 B 恰好在两次写入中间读取该指针，它可能会读到前 4 字节是旧地址、后 4 字节是新地址的“混合体”。这个“撕裂”后的地址指向的是内存中的荒野，一旦访问就会导致 **Segmentation Fault**。

### 2. 指令重排 (Instruction Reordering)

这是最隐蔽、最常考的知识点。编译器和 CPU 为了优化性能，可能会打乱指令执行顺序。

考虑插入逻辑：

1. `new_node->next[0] = next_node;` // 操作 A
2. `prev_node->next[0] = new_node;` // 操作 B

**没有 atomic 的风险**：

编译器或 CPU 可能认为 A 和 B 没有逻辑依赖，从而**先执行操作 B**。

- 此时，`prev_node` 已经指向了 `new_node`，但 `new_node` 的 `next` 指针还是个**随机的垃圾值**。
- 如果读线程此时经过 `prev_node` 跳到 `new_node`，再往后找，就会顺着垃圾值坠入深渊。

**使用 `std::atomic` 的保护**：

`store()` 默认使用 `std::memory_order_seq_cst`（顺序一致性）。它像一道“屏障”，保证在操作 B 执行前，操作 A 必须已经对所有线程可见。

------

### 3. 缓存可见性 (Visibility)

每个 CPU 核心都有自己的 L1/L2 Cache。

- 线程 A 在核心 1 修改了指针，可能只写到了自己的缓存里，没有立即同步到主存。
- 线程 B 在核心 2 读取，可能读到的是旧缓存里的过时指针。

`std::atomic` 会触发底层的**缓存一致性协议（如 MESI 协议）**，确保一旦写入，其他核心的对应缓存行会失效，迫使它们从主存拉取最新数据。

------

### 总结对比

| **现象**   | **普通指针 (Node\*)**              | **原子指针 (std::atomic<Node\*>)** |
| ---------- | ---------------------------------- | ---------------------------------- |
| **原子性** | 取决于架构，不被标准保证           | **由标准强制保证**，绝无撕裂       |
| **顺序性** | 允许重排，可能读到未初始化完的节点 | **禁止有害重排**，写操作有序可见   |
| **可见性** | 存在延迟，可能读到旧值             | **强制同步**，确保看到最新值       |

> **一句话总结**：
>
> 改成 `atomic` 是为了给编译器和 CPU “带上紧箍咒”，强制它们在多线程环境下保持严谨，别为了那点性能优化把内存地址搞乱。

**你现在可以尝试在代码里完成 `atomic` 改造了。改完后，我们可以讨论如何利用 `std::shared_mutex` 给你的 `MemTable` 穿上一层正式的“防弹衣”。**

## current_level的原子性

### 深度思考：`current_level` 的可见性

你有没有发现，`current_level` 只是一个普通的 `int`？ 在 `insert_element` 中，你会修改 `current_level`；而在 `search_element` 中，你会读取它：

```c++
for (int i = current_level - 1; i >= 0; i--) // 读取
```

如果 `insert` 线程更新了层高，但 `search` 线程因为 CPU 缓存没看到更新，它就会漏掉高层的索引。虽然这不会导致崩溃（只会导致查询变慢），但严格来说，**`current_level` 和 `node_count` 也应该改为 `std::atomic<int>`**。