# Immutable MemTable è®¾è®¡åŸç†è§£æ

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è§£é‡Š NovaKV é¡¹ç›®ä¸­ Immutable MemTable çš„è®¾è®¡åŸç†å’Œå®ç°ç»†èŠ‚ï¼Œç‰¹åˆ«é’ˆå¯¹ä¸‰ä¸ªæ ¸å¿ƒè®¾è®¡é—®é¢˜è¿›è¡Œæ·±å…¥åˆ†æã€‚

---

## ğŸ¯ æ ¸å¿ƒè®¾è®¡é—®é¢˜è§£æ

### é—®é¢˜1ï¼šä¸ºä»€ä¹ˆä½¿ç”¨ `shared_ptr<SkipList>` è€Œä¸æ˜¯ç›´æ¥åŒ…å«ï¼Ÿ

#### ğŸ” æ ¸å¿ƒåŸå› ï¼šç”Ÿå‘½å‘¨æœŸç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–

##### âŒ é”™è¯¯åšæ³•å¯¹æ¯”
```cpp
// æ–¹å¼1ï¼šç›´æ¥åŒ…å«ï¼ˆä¸æ¨èï¼‰
class ImmutableMemTable {
private:
    SkipList<K, V> skip_list_;  // ç›´æ¥åŒ…å«å¯¹è±¡
};
```

**é—®é¢˜åˆ†æï¼š**
- éœ€è¦æ·±æ‹·è´æ•´ä¸ª SkipList æ•°æ®ç»“æ„
- å†…å­˜å ç”¨ç¿»å€ï¼ˆåŸæ•°æ® + å‰¯æœ¬ï¼‰
- æ‹·è´æ“ä½œæ—¶é—´å¤æ‚åº¦ O(n)
- ææ„æ—¶éœ€è¦é¢å¤–æ¸…ç†å·¥ä½œ

##### âœ… æ­£ç¡®åšæ³•å®ç°
```cpp
// æ–¹å¼2ï¼šä½¿ç”¨ shared_ptrï¼ˆæ¨èï¼‰
class ImmutableMemTable {
private:
    std::shared_ptr<SkipList<K, V>> skip_list_;  // æ™ºèƒ½æŒ‡é’ˆ
};
```

#### ğŸ’¡ æ ¸å¿ƒä¼˜åŠ¿è¯¦è§£

**1. é›¶æ‹·è´è½¬æ¢æœºåˆ¶**
```cpp
// è½¬æ¢è¿‡ç¨‹æ¼”ç¤º
MemTable<string, string> active_table("wal.log");
// ... æ’å…¥å¤§é‡æ•°æ® ...

// è½¬æ¢ä¸º Immutable - O(1) æ—¶é—´å¤æ‚åº¦
auto skip_list_ptr = active_table.ExtractSkipList();  // è·å–æ‰€æœ‰æƒ
auto immutable_table = std::make_shared<ImmutableMemTable<string, string>>(
    std::move(skip_list_ptr),  // è½¬ç§»æ‰€æœ‰æƒï¼Œæ— éœ€å¤åˆ¶
    generate_unique_id()
);
```

**2. å¤šå¼•ç”¨å…±äº«æœºåˆ¶**
```cpp
// å¤šä¸ªç»„ä»¶å¯ä»¥å®‰å…¨å…±äº«åŒä¸€ä¸ªæ•°æ®ç»“æ„
auto table_ref1 = immutable_table;  // å¼•ç”¨è®¡æ•° = 2
auto table_ref2 = immutable_table;  // å¼•ç”¨è®¡æ•° = 3

// è‡ªåŠ¨å†…å­˜ç®¡ç†
// å½“æ‰€æœ‰å¼•ç”¨éƒ½é”€æ¯æ—¶ï¼Œshared_ptr è‡ªåŠ¨é‡Šæ”¾å†…å­˜
```

**3. å¼‚å¸¸å®‰å…¨ä¿éšœ**
```cpp
try {
    auto immutable = std::make_shared<ImmutableMemTable<K, V>>(skip_list, id);
    // å³ä½¿åç»­æ“ä½œæŠ›å‡ºå¼‚å¸¸ï¼Œshared_ptr ä¹Ÿä¼šè‡ªåŠ¨æ¸…ç†èµ„æº
} catch (const std::exception& e) {
    // èµ„æºè‡ªåŠ¨å›æ”¶ï¼Œæ— éœ€æ‰‹åŠ¨ cleanup
}
```

#### ğŸ“Š æ€§èƒ½å¯¹æ¯”åˆ†æ

| æŒ‡æ ‡ | ç›´æ¥åŒ…å« | shared_ptr æ–¹å¼ | æ€§èƒ½å·®å¼‚ |
|------|----------|-----------------|----------|
| è½¬æ¢æ—¶é—´å¤æ‚åº¦ | O(n) | O(1) | âš¡ å¿« n å€ |
| å†…å­˜ä½¿ç”¨ | 2Ã— åŸæ•°æ® | 1Ã— åŸæ•°æ® | ğŸ’¾ èŠ‚çœ 50% |
| å¼‚å¸¸å®‰å…¨æ€§ | éœ€è¦æ‰‹åŠ¨å¤„ç† | è‡ªåŠ¨ç®¡ç† | ğŸ›¡ï¸ æ›´å®‰å…¨ |
| ä»£ç å¤æ‚åº¦ | é«˜ | ä½ | ğŸ“ˆ æ›´ç®€æ´ |

---

### é—®é¢˜2ï¼š`mutable` å…³é”®å­—çš„ä½œç”¨è¯¦è§£

#### ğŸ” æ ¸å¿ƒç†è§£ï¼šé€»è¾‘å¸¸é‡æ€§ vs ç‰©ç†å¸¸é‡æ€§

##### ğŸ¯ æ¦‚å¿µåŒºåˆ†

**ç‰©ç†å¸¸é‡æ€§**ï¼šå¯¹è±¡çš„å†…å­˜çŠ¶æ€ä¸èƒ½è¢«ä¿®æ”¹  
**é€»è¾‘å¸¸é‡æ€§**ï¼šä»ä½¿ç”¨è€…è§’åº¦çœ‹ï¼Œå¯¹è±¡è¡¨ç°ä¸€è‡´

##### ğŸ’¡ å®é™…åº”ç”¨åœºæ™¯

```cpp
class ImmutableMemTable {
private:
    mutable std::shared_mutex read_mutex_;  // å…³é”®ï¼šmutable ä¿®é¥°
    
public:
    // const æ–¹æ³•ä¸­ä¿®æ”¹ mutex çŠ¶æ€
    bool Get(const K& key, V& value) const {
        // è™½ç„¶æ˜¯ const æ–¹æ³•ï¼Œä½†éœ€è¦è·å–è¯»é”
        std::shared_lock<std::shared_mutex> lock(read_mutex_);  // ä¿®æ”¹äº† mutex!
        // ... å®é™…çš„æ•°æ®æŸ¥è¯¢é€»è¾‘ ...
        return found;
    }
    
    size_t Size() const {
        std::shared_lock<std::shared_mutex> lock(read_mutex_);
        return skip_list_->size();
    }
};
```

#### ğŸ”„ ä½¿ç”¨åœºæ™¯åˆ†æ

**ä½•æ—¶ä½¿ç”¨ mutableï¼š**
1. **ç¼“å­˜å’Œä¼˜åŒ–**ï¼šå¦‚è®¡ç®—ç¼“å­˜ã€ç»Ÿè®¡ä¿¡æ¯
2. **åŒæ­¥åŸè¯­**ï¼šäº’æ–¥é”ã€æ¡ä»¶å˜é‡ç­‰
3. **æ—¥å¿—è®°å½•**ï¼šè®¿é—®ç»Ÿè®¡ã€è°ƒè¯•ä¿¡æ¯

**ä½•æ—¶é¿å…ä½¿ç”¨ mutableï¼š**
1. **ä¸šåŠ¡é€»è¾‘çŠ¶æ€**ï¼šå½±å“å¯¹è±¡è¡Œä¸ºçš„æ ¸å¿ƒæ•°æ®
2. **å¯è§æ€§æ•°æ®**ï¼šç”¨æˆ·å…³å¿ƒçš„é‡è¦å±æ€§
3. **æŒä¹…åŒ–çŠ¶æ€**ï¼šéœ€è¦åºåˆ—åŒ–çš„å…³é”®ä¿¡æ¯

#### ğŸ“š æ ‡å‡†åº“ä¸­çš„åº”ç”¨å®ä¾‹

```cpp
// std::shared_mutex çš„å…¸å‹ç”¨æ³•
class ThreadSafeCounter {
private:
    mutable std::shared_mutex mutex_;
    int count_ = 0;
    
public:
    // const æ–¹æ³•å¯ä»¥ä¿®æ”¹å†…éƒ¨åŒæ­¥çŠ¶æ€
    int GetValue() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return count_;
    }
    
    void Increment() {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        ++count_;
    }
};
```

---

### é—®é¢˜3ï¼šåŠŸèƒ½ç®€åŒ–çš„åŸå› å’Œä»·å€¼

#### ğŸ” LSM-Tree æ¶æ„ä¸‹çš„èŒè´£åˆ†å·¥

##### ğŸ“Š åŠŸèƒ½å¯¹æ¯”çŸ©é˜µ

| åŠŸèƒ½ç±»åˆ« | MemTableï¼ˆæ´»è·ƒï¼‰ | ImmutableMemTableï¼ˆåªè¯»ï¼‰ | SSTableï¼ˆæŒä¹…åŒ–ï¼‰ |
|----------|------------------|---------------------------|-------------------|
| **æ•°æ®æ“ä½œ** | è¯»/å†™/åˆ é™¤ | åªè¯» | åªè¯» |
| **WALæ—¥å¿—** | âœ… å†™å…¥ | âŒ ä¸éœ€è¦ | âŒ ä¸éœ€è¦ |
| **å†…å­˜ç®¡ç†** | åŠ¨æ€å¢é•¿ | å›ºå®šå¤§å° | æ–‡ä»¶å­˜å‚¨ |
| **åˆ·ç›˜æœºåˆ¶** | ä¸æ¶‰åŠ | ä¸»è¦èŒè´£ | æœ€ç»ˆçŠ¶æ€ |
| **å¹¶å‘æ§åˆ¶** | è¯»å†™é” | è¯»é” | æ— é” |

##### ğŸ’¡ ç®€åŒ–å¸¦æ¥çš„ä»·å€¼

**1. æ€§èƒ½ä¼˜åŒ–**
```cpp
// Immutable ç‰ˆæœ¬çš„ç®€åŒ–å®ç°
class ImmutableMemTable {
public:
    // åªä¿ç•™å¿…è¦çš„åªè¯»æ¥å£
    bool Get(const K& key, V& value) const {
        // æ— éœ€å†™é”ï¼Œåªæœ‰è¯»é”
        std::shared_lock<std::shared_mutex> lock(read_mutex_);
        return skip_list_->search_element(key, value);
    }
    
    // ç§»é™¤äº†æ‰€æœ‰å†™æ“ä½œæ¥å£
    // void Put(...) { }  // ä¸å†éœ€è¦
    // bool Remove(...) { }  // ä¸å†éœ€è¦
};
```

**2. æ¶æ„æ¸…æ™°æ€§**
```
æ•°æ®æµå‘ï¼šæ´»è·ƒ MemTable â†’ Immutable MemTable â†’ SSTable
           â†“              â†“                  â†“
        å¯è¯»å†™          åªè¯»å‡†å¤‡          æ°¸ä¹…å­˜å‚¨
        éœ€è¦WAL         æ— éœ€WAL           æ–‡ä»¶ç³»ç»Ÿ
        è¯»å†™é”          åªè¯»é”            æ— é”è®¿é—®
```

**3. èµ„æºåˆ©ç”¨æ•ˆç‡**
```cpp
// ç³»ç»Ÿä¸­å¯ä»¥åŒæ—¶å­˜åœ¨å¤šç§çŠ¶æ€çš„è¡¨
class StorageEngine {
private:
    MemTable active_table;                    // 1ä¸ªæ´»è·ƒè¡¨
    std::vector<ImmutableMemTable> immutables; // å¤šä¸ªåªè¯»è¡¨
    std::vector<SSTable> disk_tables;         // å¤šä¸ªç£ç›˜è¡¨
    
    // å†™å…¥å§‹ç»ˆæœ‰æ´»è·ƒè¡¨æ¥æ”¶ï¼Œä¸é˜»å¡
    // è¯»å–å¯ä»¥ä»æ‰€æœ‰å±‚çº§å¹¶è¡ŒæŸ¥è¯¢
};
```

#### ğŸ¯ LSM-Tree åˆ†å±‚ç­–ç•¥çš„ä»·å€¼

**å†™å…¥ä¼˜åŒ–ï¼š**
- å§‹ç»ˆæœ‰æ´»è·ƒ MemTable æ¥æ”¶å†™å…¥è¯·æ±‚
- Immutable MemTable åå°å¼‚æ­¥åˆ·ç›˜
- å†™å…¥å»¶è¿Ÿå‡ ä¹ä¸ºé›¶

**è¯»å–ä¼˜åŒ–ï¼š**
- å¤šå±‚çº§å¹¶è¡ŒæŸ¥è¯¢
- Bloom Filter å¿«é€Ÿè¿‡æ»¤
- æœ€è¿‘æ•°æ®åœ¨å†…å­˜ä¸­ï¼Œè®¿é—®é€Ÿåº¦å¿«

**ç©ºé—´ä¼˜åŒ–ï¼š**
- æ‰¹é‡åˆ·ç›˜å‡å°‘ IO æ¬¡æ•°
- åå° Compaction åˆå¹¶æ•°æ®
- æœ‰åºå­˜å‚¨æé«˜å‹ç¼©æ•ˆç‡

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è§†è§’

### LSM-Tree å®Œæ•´æ•°æ®æµ

```mermaid
graph LR
    A[å®¢æˆ·ç«¯å†™å…¥] --> B[æ´»è·ƒMemTable]
    B --> C{è¾¾åˆ°é˜ˆå€¼?}
    C -->|å¦| B
    C -->|æ˜¯| D[è½¬æ¢ä¸ºImmutable]
    D --> E[åˆ›å»ºæ–°æ´»è·ƒMemTable]
    D --> F[åå°åˆ·ç›˜çº¿ç¨‹]
    F --> G[SSTableæ–‡ä»¶]
    E --> A
```

### å¹¶å‘è®¿é—®æ¨¡å¼

```mermaid
graph TD
    A[è¯»è¯·æ±‚] --> B{æŸ¥è¯¢å±‚çº§}
    B --> C[æ´»è·ƒMemTable]
    B --> D[Immutable MemTable]
    B --> E[SSTable]
    C --> F[è¯»å†™é”]
    D --> G[åªè¯»é”]
    E --> H[æ— é”è®¿é—®]
    F --> I[åˆå¹¶ç»“æœ]
    G --> I
    H --> I
    I --> J[è¿”å›å®¢æˆ·ç«¯]
```



---

## ğŸ“ æ€»ç»“

Immutable MemTable çš„è®¾è®¡ä½“ç°äº†å‡ ä¸ªé‡è¦çš„è½¯ä»¶å·¥ç¨‹åŸåˆ™ï¼š

1. **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªç»„ä»¶ä¸“æ³¨äºç‰¹å®šåŠŸèƒ½
2. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
3. **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šé€šè¿‡æŠ½è±¡è€Œéå…·ä½“å®ç°è€¦åˆ
4. **æ€§èƒ½ä¼˜å…ˆ**ï¼šåœ¨ä¿è¯æ­£ç¡®æ€§çš„å‰æä¸‹è¿½æ±‚æè‡´æ€§èƒ½

è¿™äº›è®¾è®¡å†³ç­–ä¸ä»…è§£å†³äº†å½“å‰çš„æŠ€æœ¯é—®é¢˜ï¼Œæ›´ä¸ºç³»ç»Ÿçš„å¯æ‰©å±•æ€§å’Œç»´æŠ¤æ€§å¥ å®šäº†åšå®åŸºç¡€ã€‚