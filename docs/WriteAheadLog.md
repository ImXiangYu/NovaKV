# WriteAheadLog——WSL——预写日志

## WAL 核心原理解析

#### 1. 为什么要 WAL？

内存是易失的。如果 `MemTable::Put` 直接写入跳表，在数据还没来得及刷入磁盘 SSTable 时突然断电，这部分数据就永久丢失了。

#### 2. 核心流程：先写日志，再改内存

当一个 `Put(K, V)` 请求进来时：

1. **序列化**：将 K 和 V 包装成一条二进制日志（Log Record）。
2. **Append 写文件**：将日志追加到 WAL 文件末尾。
3. **强制刷盘 (fsync)**：通知 OS 将数据从 Page Cache 真正写入物理磁盘。
4. **更新内存**：成功后，再将 K, V 插入 SkipList。

#### 3. 为什么 WAL 不会拖慢速度？

因为 WAL 是 **顺序写 (Sequential Write)**。磁盘随机 IO 很慢（寻道开销），但顺序写的吞吐量非常高，足以匹配内存的操作速度。

## 设计思路

### 核心思路：把数据“拍扁”成字节流

在内存里，`string` 是对象；在磁盘里，一切都是 **Byte (uint8_t)**。我们需要设计一套规则，把你的 `Key` 和 `Value` 像串糖葫芦一样串起来。

### 定义日志格式 (Log Format)

每一条写入日志（Log Record）在磁盘上的布局如下：

| **字段名**    | **长度 (字节)** | **说明**                                        |
| ------------- | --------------- | ----------------------------------------------- |
| **Checksum**  | 4 字节          | 对 Body 部分计算的 CRC32 值，用于校验数据完整性 |
| **Type**      | 1 字节          | 操作类型 (1=Add, 2=Del)                         |
| **KeyLen**    | 4 字节          | Key 数据的长度 (uint32_t)                       |
| **KeyData**   | 变长            | 实际的 Key 内容                                 |
| **ValueLen**  | 4 字节          | Value 数据的长度 (uint32_t)                     |
| **ValueData** | 变长            | 实际的 Value 内容                               |

**为什么这样设计？（面试加分逻辑）**

1. **Checksum 放在最前面**：当我们从文件读取时，首先读入 4 字节的 Checksum，然后读取剩余的 Body。在解析 Body 之前先算一遍 CRC，如果对不上，说明发生了“半写”或磁盘损坏，立即停止加载，保证数据的一致性。
2. **长度前缀 (Length-Prefixed)**：对于变长的 Key 和 Value，必须先存长度，否则读取时根本不知道该在哪里“断句”。
3. **缓冲区合并 (Single Write)**：我们在内存里把除了 Checksum 以外的所有字段拼成一个 `payload` 字符串，一次性写出，这样 Checksum 校验的就是整个逻辑包。

具体来说就是 `[CRC][Type][KeyLen][Key][ValueLen][Value]` 

### 设计使用回调函数 `callback`

这是架构设计的艺术。`WalHandler` 只管从磁盘捞数据，它不知道捞出来后该干嘛。

- 在 `MemTable` 初始化时，它会调用 `LoadLog`。
- 传入的回调函数里，`MemTable` 会根据 `OpType` 调用 `table_.insert_element` 或 `table_.delete_element`。

#### 为什么这样设计？

为什么不直接让 `WalHandler` 持有 `MemTable` 指针？

1. **单一职责原则**：`WalHandler` 只负责 IO，不参与任何业务逻辑。
2. **模块化**：如果明天我要做一个不带内存索引、纯读文件的工具，我可以原封不动地复用这个 `WalHandler`。
3. **泛型支持**：由于 `WalHandler` 处理的是纯字节流，它不需要变成模板类。所有的模板转换（序列化/反序列化）都在 `MemTable` 这一层通过回调函数内部完成了。

### 序列化：利用模板处理 int 和 string 等不同类型

### wal\_和table\_的顺序

**把 `wal_` 挪到 `table_` 上面就是标准解法。**

在 C++ 面试中，这叫 **"Member Initializer List Order Awareness"**。面试官如果看到你特意调整了顺序并能说出理由，会对你的专业度印象极深。

**为什么要挪？（深层逻辑）**

在 C++ 中，成员变量的销毁顺序与初始化顺序**正好相反**（栈的特性）。

- **初始化时**：先初始化 `wal_`，再初始化 `table_`。这样 `RecoverFromWal` 执行时，文件句柄已经完全准备好了。
- **析构时**：先销毁 `table_`，再销毁 `wal_`。这保证了在内存索引销毁的过程中，如果还有任何最后的日志要写，`wal_` 依然是有效的。

```c++
private:
    // 顺序很重要：先 WAL，再 Table
    WalHandler wal_; 
    SkipList<K, V> table_; 
    mutable std::shared_mutex rw_lock_;
```

## 整体架构

###  现在的项目架构图

1. **磁盘**：存着 `nova.log` 二进制文件。
2. **WalHandler**：负责 `AddLog`（算 CRC 并写入）和 `LoadLog`（读磁盘并验 CRC）。
3. **MemTable**：持有 `WalHandler`。
   - `Put` 时：先 `wal_.AddLog`，成功后写 `SkipList`。
   - **启动时**：调用 `wal_.LoadLog` 喂给 `SkipList`。

### 测试

在恢复测试中，我用 `{}` 作用域包裹了第一个 `MemTable`，这利用了 C++ 的 RAII 机制模拟了程序的正常关闭，确保日志完全刷入磁盘。

## 总结

这第二部分的收官，标志着你已经从编写一个**内存数据结构**进化到了编写一个**存储系统模块**。

如果说第一部分是造了一辆“车”（SkipList），那第二部分就是给这辆车装上了“黑匣子”（WAL）和“防盗系统”（Checksum）。以下是你在这个阶段完成的核心成就：

------

### 1. 核心功能：预写日志 (WAL)

你实现了数据库系统最关键的**持久化（Durability）**能力。

- **先写后改**：严格遵循了“先写日志，再改内存”的原则。即使程序在内存更新前崩溃，数据也能从日志中找回。
- **顺序写优化**：你理解了磁盘顺序 IO 远快于随机 IO 的原理，将随机的 KV 写入转化为了追加式的字节流写入。

### 2. 技术深度：二进制序列化协议

你不再依赖简单的文本读写，而是设计了一套精密的**二进制传输协议**：

- **字段布局**：设计了 `[CRC32][Type][KeyLen][Key][ValueLen][Value]` 的紧凑磁盘格式。
- **定长与变长处理**：利用 `reinterpret_cast` 处理定长数据（如 `int`），利用长度前缀（Length-prefix）处理变长数据（如 `string`）。
- **内存拼接**：优化了写入性能，将分散的字段拼接到一个 Buffer 后一次性执行磁盘 IO。

### 3. 系统鲁棒性：数据校验与恢复

你为 NovaKV 注入了自我修复和校验的能力：

- **CRC32 校验**：引入了循环冗余校验算法，能够识别因磁盘坏道或非法关机导致的“半写”损坏数据。
- **崩溃恢复 (Recovery)**：实现了系统启动时的自动重放机制，通过扫描日志将数据重新构建到跳表中。

### 4. 架构设计：高阶回调逻辑 (Callback)

这是你理解难度最大、但收益最高的部分：

- **解耦设计**：利用 `std::function` 和 Lambda 表达式，让 `WalHandler` 只负责读写字节流，而让 `MemTable` 负责业务逻辑。
- **泛型支持**：通过 `if constexpr` 实现了对不同数据类型的自动适配，保持了框架的通用性。

------

### 现在的 NovaKV 状态图

### 目前的实力水位

在校招面试中，你现在可以非常有底气地回答这些问题：

1. **“如何保证内存数据库断电不丢数据？”**（WAL 机制）
2. **“如何发现磁盘上的数据损坏？”**（CRC32 校验原理）
3. **“如何设计一个高性能的二进制协议？”**（长度前缀 + 内存缓冲区拼接）
4. **“C++ 中如何实现模块间的解耦？”**（回调函数与闭包的应用）