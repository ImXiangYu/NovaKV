# 📖 NovaKV 核心设计文档：LSM-Tree 存储闭环

## 1. 核心痛点：为什么不能只有 WAL？

在当前的实现中，WAL（预写日志）解决了数据的**安全性**问题，但没有解决**管理**问题：

- **内存空间受限**：数据无法超过物理内存。
- **重启恢复缓慢**：若日志高达数 GB，重启重放（Replay）将耗费极长时间。
- **检索效率低**：WAL 是追加式写入（乱序），无法支持磁盘上的快速随机查询或范围查询。

## 2. 解决方案：SSTable 与日志截断

为了解决上述问题，NovaKV 引入了 **SSTable (Sorted String Table)** 机制。

### 🔄 数据生命周期

1. **活跃阶段 (Active)**：数据写入 **WAL** 并更新 **MemTable**（SkipList）。
2. **冻结阶段 (Freeze)**：当 MemTable 达到阈值（如 4MB），它会转换为 **Immutable MemTable**。此时，旧的 WAL 停止写入，系统开启新的 WAL 和 MemTable 接收新请求。
3. **持久化阶段 (Flush)**：后台线程将 Immutable MemTable 中的有序数据“拍扁”并序列化，生成一个 **SSTable 文件**。
4. **清理阶段 (Truncate)**：一旦 SSTable 成功落盘，该文件已包含该阶段所有数据。此时，与之对应的 **旧 WAL 即可被物理删除**。

### ⚖️ WAL 与 SSTable 的角色博弈

- **WAL（救命）**：追求 **写性能**。顺序追加，不求有序，只求在内存数据丢失时能提供恢复凭证。
- **SSTable（生活）**：追求 **读性能**。它是 MemTable 在磁盘上的“镜像”，按 Key 字典序排列，支持索引和二分查找。

## 3. 关键结论

- **WAL 不会无限膨胀**：它的长度被限制在“待刷盘内存数据”的大小范围内。SSTable 的生成过程就是 WAL 空间释放的过程。
- **读写分离**：正常读取数据时，跳过 WAL，直接检索 MemTable 和 SSTable。