### 1. 为什么要用跳表？（背景）

在内存中，我们需要一个**有序**的数据结构。

- **普通链表**：有序，但查找是 $O(N)$，太慢。
- **平衡树（如红黑树）**：查找是 $O(\log N)$，很快。但在高并发下，红黑树的“平衡旋转”操作会锁定大片区域，性能打折。
- **跳表**：查找也是 $O(\log N)$，但它通过**概率**保证平衡。它的结构简单，插入时只需要修改局部指针，非常适合高并发的数据库内核。

------

### 2. 跳表的核心原理：多层索引

跳表的本质是**“空间换时间”**。它在原始链表之上，建立了多层“索引层”。

- **第 0 层**：原始链表，包含所有数据。
- **第 1 层**：每隔一个节点跳一个（理想情况下）。
- **第 i 层**：索引更加稀疏。

**查找过程（类似二分）**：

假设你要找 `17`。

1. 从**最高层**开始往右走。
2. 如果发现“下一个节点比 17 大”或者“到头了”，就**垂直向下**掉到下一层，继续往右走。
3. 通过这种“横向跨越、纵向降层”，你可以跳过大量无关数据。

![image-20260201222307511](https://s2.loli.net/2026/02/01/Ft7iAgxW4GbBJrd.png)

------

### 3. 核心挑战：如何维持平衡？（随机化）

如果你固定“每两个节点抽一个做索引”，那么插入或删除一个节点时，整层索引都要重新调整，开销巨大。

**跳表的神来之笔**：

每个节点在插入时，**抛硬币**决定自己有多少层。

- 50% 概率只有 1 层。

- 25% 概率有 2 层。

- 12.5% 概率有 3 层……

  这种随机化保证了，在大规模数据下，跳表的结构在统计学上是趋于完美的 $O(\log N)$，且插入新节点时，**只需要修改它前后节点的指针**，不影响全表。

------

### 4. 关键动作分解

#### A. 寻找插入位置（Update 数组）

这是实现跳表最重要的一步。在插入 Key 为 `K` 的节点前，你需要从最高层向下搜索，并用一个 `update` 数组记录下**每一层中在 K 之前的最后一个节点**。

> 想象你在盖楼，`update` 数组就是每一层你准备接电线的那个“插座”。

#### B. 修改指针

1. 随机生成一个层数 `L`。

2. 创建一个新节点，高度为 `L`。

3. 遍历 `0` 到 `L-1` 层，利用 `update` 数组把新节点嵌进去。

   - `new_node->next[i] = update[i]->next[i]`

   - `update[i]->next[i] = new_node`

     （这其实就是单链表插入的“加强版”）

### 神来之笔！

创建：![image-20260201235030455](https://s2.loli.net/2026/02/01/SIxTCrf8DgLmcFn.png)

 查找：
![image-20260201235055499](https://s2.loli.net/2026/02/01/Raxj4vdDOSQI927.png)

插入：
![image-20260201235144483](https://s2.loli.net/2026/02/01/1zPmUrAWCBhKEe6.png)