## 第一阶段（核心存储结构）

### 1. 核心数据结构：跳表 (SkipList)

你避开了传统的平衡树（如红黑树），选择了更适合高并发数据库场景的**跳表**。

- **概率对数级索引**：你实现了一套基于“抛硬币”概率算法的动态索引层，使得查询、插入和删除的时间复杂度稳定在 $O(\log n)$。
- **分层思想**：你理解了如何通过“空间换时间”，在原始链表之上构建多层索引，实现了类似二分查找的效率。
- **代码实现能力**：你处理了复杂的指针操作（前驱节点数组 `update`），这在底层开发中是非常核心的功力。

### 2. 并发架构：读写锁 (Read-Write Lock)

你让你的数据库具备了多线程作业的能力：

- **读写分离**：引入了 `std::shared_mutex`。
- **高并发吞吐**：实现了“多读单写”逻辑。多个线程可以同时读取数据而互不阻塞，只有在修改数据时才会锁定。这对于数据库这种“读多写少”的场景是巨大的性能优化。

### 3. 泛型与接口设计

- **模板化 (Template)**：你将 `MemTable` 设计为模板类，支持 `K` 和 `V` 的自由组合（如 `int` 到 `string`，或 `string` 到 `int`）。
- **极简 API**：你提炼出了数据库最基础的三个操作：`Put` (写/更), `Get` (读), `Remove` (删)。这三个接口是所有上层应用（如 SQL 解析器）的基础。

### 4. 内存管理与防御性编程

- **RAII 机制**：利用 C++ 的析构函数管理资源，确保对象销毁时内存不泄露。
- **默认实参优化**：你在构造函数中处理了 `max_level` 等参数，兼顾了易用性与灵活性。

## 第二阶段（可持久化存储引擎）

在这一阶段，你完成了一个从“纯内存数据结构”到“可持久化存储引擎”的华丽转身。

### 1. 持久化防线：WAL (Write-Ahead Logging)

- **先写后动**：你实现了 `AddLog` 接口，确保每一条指令在进入跳表之前，先以追加（Append）的方式安全写入磁盘。
- **原子性保障**：通过日志记录，你解决了内存易失性的问题。即便程序在第 9999 次写入时断电，第 10000 次启动时它依然能“记起”所有数据。

### 2. 磁盘协议设计：Binary Protocol

你手动设计了一套紧凑的二进制存储格式，这比 JSON 或 XML 高效得多：

- **结构布局**：`[CRC32 (4B)] [Type (1B)] [KeyLen (4B)] [Key] [ValueLen (4B)] [Value]`。
- **墓碑机制 (Tombstone)**：你处理了删除逻辑，通过存入一个 `OpType::DEL` 类型的日志条目，在恢复时能准确地在跳表中移除键值。

### 3. 数据完整性：Checksum & Safety

- **数据校验**：引入了 **CRC32** 循环冗余校验。这让你能识别出因为硬件故障、系统断电导致的“半写（Partial Write）”或数据篡改。
- **初始化保护**：你学习并修复了 C++ 类成员初始化顺序的隐患，确保 `WalHandler` 总是先于 `Table` 准备就绪，且最后被销毁。

### 4. 架构艺术：Decoupling & Generics

- **回调解耦**：利用 `std::function` 和 **Lambda 闭包**，实现了 `WalHandler`（只管 IO）与 `MemTable`（只管逻辑）的完美分离。
- **序列化抽象**：通过 `if constexpr` 模板技术，你的引擎现在既能处理 `int`，也能处理 `std::string`，具备了通用的泛型存储能力。