# NovaKV 迭代器实现原理与落地起步

## 1. 这类迭代器在做什么
LSM 的用户迭代器本质是三件事叠加：
- 多路有序流合并（MemTable + L0 + L1）
- 同 key 版本裁决（最新版本胜出）
- Tombstone 过滤（删除标记不对用户可见）

不是简单“顺序扫一份数组”。

## 2. 必须保证的语义（验收标准）
- 输出 key 全局递增。
- 同一个 key 最多输出一次。
- 若同 key 有多个版本，输出最新版本。
- 若最新版本是 `kDeletion`，该 key 不输出。

## 3. 为什么需要合并迭代器
数据分布在多个来源，且同 key 可能跨层重复：
- `MemTable`：最新
- `L0`：多文件，范围可重叠，文件新旧有先后
- `L1`：更旧层

因此用户迭代器不能“先到先得”，必须在同 key 上做优先级裁决。

## 4. 实现原理（推荐模型）
1. 每个来源先做成“source iterator”（统一接口：`Seek/Next/Valid/key/value/type`）。
2. 每个 source 都执行 `Seek(start_key)`。
3. 用最小堆按 key 维护每个 source 的当前候选。
4. 每次取最小 key，把所有同 key 候选收集到一组。
5. 对该组按新旧优先级选赢家：
   - `MemTable > L0 新文件 > L0 旧文件 > L1 ...`
6. 赢家为 `kValue` 则输出，赢家为 `kDeletion` 则跳过。
7. 将本轮被消费的 source 执行 `Next()` 并重新入堆，继续循环。

## 5. 分层设计建议
先把底层来源标准化，再做总合并：
- `MemTableIterator`
- `SSTableIterator`（可基于 `ForEach` 先做功能版）
- `DBIterator`（只关心合并、去重、过滤）

这样后续扩展 L2/L3、后台压实时不会重写用户接口。

## 6. 建议实现顺序（最稳）
1. 先补接口壳子：`DBImpl::NewIterator()` + 迭代器类定义。
2. 先实现仅 MemTable 的迭代行为，跑通基础顺序测试。
3. 接入 L0 数据源，做同 key 去重与新版本裁决。
4. 接入 L1，保持统一裁决逻辑。
5. 增加 tombstone 过滤（最新为删除则隐藏）。

## 7. 你现在应该从哪里开始
从 `include/DBImpl.h` 开始，先定义接口而不是先写复杂逻辑。

第一批最小改动目标：
- 在 `DBImpl` 增加 `NewIterator()` 声明。
- 增加迭代器类型声明（可先前置声明 + 独立头文件）。
- 明确返回类型（建议 `std::unique_ptr<...>`）。

完成接口后再去 `src/DBImpl.cpp` 提供空实现，确保工程可编译，再逐步填充行为。
