# 回调函数(callback)

## 什么是回调函数？

在 C++ 中，**回调函数（Callback）** 的本质就是：**“我现在定义逻辑，但留到以后某个时刻由别人来调用。”**

我们可以把 C++ 的回调演进看作是从“原始社会”向“现代工业”的进化过程。

------

### 1. 原始时代：函数指针 (Function Pointers)

这是最底层的回调方式，直接传递函数的内存地址。

- **优点：** 性能极致，无额外开销。
- **缺点：** 语法极其反人类；**无法捕获状态**（只能处理静态函数或全局函数）。

```C++
// 定义一个函数指针类型：返回值为void，参数为int
typedef void (*CallbackPtr)(int);

void performTask(int value, CallbackPtr callback) {
    // 做一些工作...
    callback(value * 2); // 触发回调
}

void myAppLogic(int result) {
    std::cout << "结果是: " << result << std::endl;
}

// 调用
performTask(10, myAppLogic);
```

------

### 2. 进阶时代：std::function (通用函数包装器)

这是现代 C++ 中最常用的回调处理方式。它是一个模板类，可以存储、复制和调用任何“可调用对象”（Callable）：普通函数、Lambda、甚至类成员函数。

**为什么用它**？

函数指针要求类型必须严格匹配，而 `std::function` 更加宽容且强大。

```C++
#include <functional>

class Downloader {
public:
    // 使用 std::function 定义回调接口
    using ProgressCallback = std::function<void(int)>;

    void start(ProgressCallback cb) {
        for(int i = 0; i <= 100; i += 50) {
            cb(i); // 调用回调
        }
    }
};
```

------

### 3. 类成员函数作为回调 (std::bind)

这是初学者最容易卡壳的地方。普通函数指针**不能**直接指向类的非静态成员函数，因为成员函数需要一个 `this` 指针。

如果你想把某个类的方法作为回调，你需要 `std::bind` 或者（你熟悉的）Lambda：

```C++
class UI {
public:
    void updateSlider(int val) { /* 更新界面 */ }
};

UI myUI;
Downloader dl;

// 错误做法：dl.start(myUI.updateSlider); 
// 正确做法 1：使用 Lambda (推荐)
dl.start([&myUI](int p) { myUI.updateSlider(p); });

// 正确做法 2：使用 std::bind
dl.start(std::bind(&UI::updateSlider, &myUI, std::placeholders::_1));
```

------

### 4. 深度对比：回调的实现方案

| **特性**   | **函数指针**  | **std::function**         | **模板 (泛型回调)** |
| ---------- | ------------- | ------------------------- | ------------------- |
| **性能**   | 极高 (内联)   | 中等 (有虚函数开销)       | 极高 (编译期确定)   |
| **灵活性** | 差 (仅限函数) | 极强 (支持任何可调用对象) | 强                  |
| **可读性** | 糟糕          | 优秀                      | 较复杂              |

------

### 5. 什么时候用哪种？

1. **性能至上（如嵌入式、底层驱动）：** 使用**函数指针**或**模板**。
2. **业务逻辑、应用开发：** 首选 **`std::function` + Lambda**。它平衡了可读性和灵活性。
3. **异步编程：** 回调通常配合 `std::async` 或事件循环使用，确保回调发生时，被捕获的对象依然有效（注意 `shared_ptr` 的生命周期）。

### 避坑指南：生命周期

在使用 Lambda 作为回调时，最危险的操作是 **捕获了局部变量的引用**。

```C++
void setup() {
    int local_val = 10;
    async_call([&]() { 
        // 报错！当回调执行时，local_val 可能已经出栈销毁了
        std::cout << local_val; 
    });
}
```

> **金律：** 异步回调尽量使用**值捕获** `[=]` 或 `std::shared_ptr`。



## 回调函数和普通的函数调用有什么区别？

这是一个非常经典的问题。其实，**回调函数**和**普通函数调用**最大的区别在于：**谁是逻辑的主宰者。**

简单来说：

- **普通调用（Direct Call）：** 你控制代码，你决定什么时候去拿数据。
- **回调函数（Callback）：** 你定义逻辑，然后**坐等**别人在合适的时机来找你（所谓“好莱坞原则”：Don't call us, we'll call you）。

以下是三个普通函数调用完全无法替代回调的场景：

------

### 1. 异步任务：你不能一直等

假设你在写一个网络游戏，需要从服务器下载一张地图。

- **普通调用：** 你的程序会停在 `download()` 这一行，直到 1GB 的地图下载完。画面卡死，玩家摔键盘。
- **回调：** 你告诉系统：“去下载吧，**下载完了之后**，执行我给你的这个 Lambda（更新进度条）。” 你的主程序继续跑，画面不卡顿。

------

### 2. 软件的分层设计：低层代码不能调用高层代码

这是回调最核心的工程价值。

想象你在写一个通用库（比如：**按钮点击库**）。

- 库的代码在 3 年前就写好了（低层）。
- 你的业务逻辑（比如：点击按钮后“发送邮件”）是今天才写的（高层）。

**矛盾点：** 3 年前的库代码，怎么可能预知并调用你今天写的 `sendEmail()` 函数呢？

- **解决方案：** 按钮库留出一个 `std::function` 槽位。你今天写好业务逻辑，把它作为回调“注入”进去。库不需要知道你具体干了什么，它只负责在按钮被按下的瞬间，拨通你给它的那个“电话号码”。

------

### 3. 通用算法：解耦逻辑与策略

以 `std::sort` 为例。

- **普通调用：** 如果 `sort` 只能按从小到大排序，那它就写死了。
- **回调：** `sort` 允许你传入一个比较规则（回调）。

```C++
std::vector<int> nums = {5, 2, 8, 1};

// 我们把“排序策略”通过回调注入进去
std::sort(nums.begin(), nums.end(), [](int a, int b) {
    return a > b; // 我定义的回调：我要从大到小排！
});
```

这里的 `sort` 就像是一台机器，它负责“搬运数据”，而具体的“对比规则”由你通过回调临时决定。

------

### 总结：普通调用 vs 回调

| **维度**     | **普通函数调用**           | **回调函数**                               |
| ------------ | -------------------------- | ------------------------------------------ |
| **调用方向** | 上层调用下层               | 下层（库/系统）反向调用上层                |
| **时间点**   | 立即执行，顺序执行         | 以后执行，通常由某个“事件”触发             |
| **依赖关系** | 调用者必须知道被调用者是谁 | 库不需要知道你，只需要一个符合规格的接口   |
| **典型比喻** | 你去柜台买饭，站那死等     | 你扫码下单，回座位玩手机，饭好了震动提醒你 |

------

### 真实案例：定时器

如果让你实现一个“每隔 5 秒在屏幕上印一句话”的功能，你会发现：

- 如果不使用回调，你必须写一个死循环不断检查时间（极度浪费 CPU）。
- 使用回调，你只需告诉系统：`timer.setInterval(5s, [](){ cout << "Hello"; });`。然后你的程序就可以去处理别的事情了。

## 回调函数和多线程

你的直觉非常敏锐！**回调（Callback）** 和 **多线程（Multi-threading）** 确实经常“成双成对”出现，但它们是两个完全不同的维度：

- **多线程是“空间”上的：** 解决的是“谁来干”的问题（再找一个人帮我干）。
- **回调是“逻辑”上的：** 解决的是“干完之后通知谁”的问题。

我们可以通过一个生活中的例子把这两个概念彻底剥离开。

### 1. 只有回调，没有多线程（单线程异步）

**场景：去餐馆点餐。**

1. 你在柜台点了一份炒饭，付了钱。
2. 你**没有**站在柜台死等（非阻塞）。
3. 你给老板留下你的电话（**注册回调**）。
4. 老板炒好饭后，拨通电话通知你（**触发回调**）。

**注意：** 整个过程中，老板只有一个人（单线程）。他炒饭的时候不能接电话，接电话的时候不能炒饭。**回调只是为了让他炒完饭后知道该找谁，而不是为了让他能同时炒两份饭。**

> 在编程中，**JavaScript** 和 **Node.js** 就是典型的单线程+大量回调。它们利用操作系统底层的能力（如 IO 多路复用），在单线程下通过回调处理成千上万的任务。

------

### 2. 只有多线程，没有回调

**场景：家里请了两个保姆。**

1. 你告诉保姆 A：“你去把地擦了。”
2. 你告诉保姆 B：“你去把菜洗了。”
3. 然后你去书房看书了。

**结局：** 两个保姆干完活就直接歇着了，**没人告诉你活干完了**。你得自己时不时出来看一眼（这叫**轮询/Polling**）。

------

### 3. 多线程 + 回调（最常见的工业形态）

这是你觉得它们“像”的原因。

**场景：外卖平台。**

1. 你下单（主线程）。
2. 平台派了一个外卖员（开辟子线程）。
3. 你在下单时输入了地址和电话（**注册回调**）。
4. 外卖员送达后，按照地址敲门（**在子线程中执行回调逻辑**）。

------

### 4. 为什么不能只用多线程替代回调？

如果你只开线程，不用回调，你会遇到以下麻烦：

**A. 资源浪费（轮询问题）**

如果不给线程传回调，主线程为了知道子线程结束了没，必须不停地问：

```c++
while(!task_done) { ... }
```

这就像你每隔 1 分钟给快递员打个电话问“到了没”，非常心累。而回调是“到了我叫你”。

**B. 逻辑脱节**

多线程负责把任务搬到后台执行，但**任务执行完后的结果怎么处理**？

- **回调方案：** `download(url, [](Data d){ saveToDisk(d); })`。逻辑是连贯的，下载完顺手就存了。
- **纯线程方案：** 你得在主线程里写一堆复杂的逻辑去监听、同步、取回子线程里的数据。

------

### 两者的协作关系

| **概念**   | **负责的事情** | **程序员的视角**                       |
| ---------- | -------------- | -------------------------------------- |
| **多线程** | **并发执行**   | “去，在后台帮我开个小灶。”             |
| **回调**   | **后续通知**   | “干完活后，记得按照这个方子把药煎了。” |

**现实代码中：**

我们通常在主线程发起一个异步调用，这个调用内部可能**新开了一个线程**去跑，当那个线程跑完时，它会**反过来执行**我们传进去的回调函数。

这就是为什么你会觉得它们像，因为在现代 C++（比如 `std::async` 或 `boost::asio`）中，它们通常是绑在一起出现的。

既然你提到了多线程，想不想看看在 C++ 中如何**优雅地**写一个带回调的线程包装器？它可以让你在子线程干完活后，自动在主线程执行一段逻辑。

## 总结

太棒了，你的理解已经完全抓住了 C++ 回调函数的**神髓**。

如果把你的理解提炼成一份“技术思维导图”，可以完美总结为这两个维度的平衡。我按照你的思路，用更工程化的语言帮你固化一下：

------

### 🚀 维度一：派发任务 (Dispatching)

**—— “把逻辑打包，交给未来”**

这就是你说的：让别的函数（或线程、系统）做完任务后，执行你传进去的 Lambda。

- **核心痛点：** 解决**“什么时候干”**（When）的问题。
- **你的视角：** 这里的回调像是一张**“便条”**。你把任务托付给一个“办事处”（比如异步 IO、定时器、子线程），并在便条上写好：“活儿干完后，请按便条上的步骤处理结果”。
- **Lambda 的加持：** 它是这张便条的“扩展包”，不仅写了逻辑，还利用**捕获列表**带走了当前的“干粮”（局部变量状态），确保未来执行时环境不丢失。

------

### 🏗️ 维度二：支援未来 (Provisioning)

**—— “把位置留好，等待注入”**

这就是你说的：自己留好接口位置，只要别人注入函数进来就行。

- **核心痛点：** 解决**“怎么干”**（How）和**“解耦”**（Decoupling）的问题。
- **你的视角：** 这里的回调像是一个**“插槽”**。你写的是一套通用的自动化流水线（框架、类库），你并不关心流水线上具体加工的是苹果还是手机。你只需要预留一个标准功率的插口，具体的加工逻辑由别人（调用者）在运行时“插”进来。
- **工程价值：** 它是**控制反转（IoC）**最简单的实现。底层代码不需要改动，通过更换注入的回调，就能让程序展现出完全不同的行为。

------

### 💡 深度总结

你所说的这两个视角，其实对应了软件工程中两个极其重要的身份：

1. **作为“调用者”：** 你在使用回调来处理**异步和结果**。
2. **作为“设计者”：** 你在利用回调提供**扩展性和灵活性**。

