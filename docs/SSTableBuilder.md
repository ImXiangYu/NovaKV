## 🏗️ 第一阶段：SSTable 写入器的宏观实现

SSTable（Sorted String Table）的核心定义是：**有序、不可变、分块、带索引**。为了实现它，我们构建了三层逻辑架构：

### 1. 最小单元：BlockBuilder（“打包盒”）

这是最底层的数据搬运工。它负责把散乱的 KV 对按照 `[KeyLen][Key][ValueLen][Value]` 的格式压入缓冲区。

- **设计要点**：它不关心磁盘，只关心**内存布局**。
- **触发机制**：当这个“盒子”装的数据接近 4KB 时，它会通知上层：“我满了，快把我写到磁盘去”。

### 2. 核心大脑：SstableBuilder（“厂长”）

它是整个流程的控制中心，负责协调内存数据与磁盘文件的关系。

- **Add 过程**：用户每 Add 一个 Key，厂长就把它丢进当前的 Data Block。
- **自动切分**：一旦 Data Block 满 4KB，厂长调用 `WriteDataBlock`：
  1. 计算当前文件的偏移量（Offset）。
  2. 将 Data Block 序列化为二进制流写入磁盘。
  3. **核心步骤**：在内存里偷偷记下这个 Block 的 **Last Key** 和它的 **位置(Offset/Size)**。这就是以后索引的来源。

### 3. 收尾工程：Finish（“封箱”）

当用户说“写完了”时，真正精彩的才开始：

1. **清空余货**：把内存里最后一个没满 4KB 的 Data Block 强行刷入磁盘。
2. **构建地图 (Index Block)**：拿出刚才记的小本本，把所有的块位置信息，再次利用 `BlockBuilder` 压成一个特殊的块——**索引块**。
3. **挂载罗盘 (Footer)**：在文件最末尾写下 24 字节。

------

## 🚩 深度复盘：你遇到的三大“天坑”

在实现上述逻辑时，你遇到的三个问题几乎覆盖了 C++ 底层开发的全部痛点：

### 1. 递归死循环：当逻辑走进“莫比乌斯环”

- **场景**：你在 `WriteDataBlock` 内部又调用了 `WriteDataBlock`。
- **后果**：**139 段错误 (Stack Overflow)**。
- **详细解析**：在 408 计组中，每次函数调用都会在内存栈区压入一个 **栈帧 (Stack Frame)**。因为你的递归没有退出出口，数万个栈帧瞬间塞满了操作系统分配给进程的栈空间（通常 8MB）。这告诉我们：**底层逻辑中，要把“状态触发”和“具体动作”分清楚。**

### 2. 静态成员的符号孤儿：Undefined Reference

- **场景**：定义了 `static const uint64_t kMagicNumber` 却无法链接。
- **原因**：当你对一个只有声明的静态常量进行 `&`（取地址）或 `reinterpret_cast` 操作时，链接器在 **符号表 (Symbol Table)** 里找不到它的物理地址。
- **解决**：使用 **C++17 `inline static`**。它让头文件变量拥有了“强符号”属性，保证了全局唯一性且分配了实际内存。

### 3. 初始化顺序的隐暗箭

- **陷阱**：C++ 类成员的初始化顺序是按**声明顺序**来的，而不是你在构造函数后面那一排括号里的顺序。
- **后果**：如果你先声明了 `builder_` 后声明了 `file_`，但 `builder_` 初始化需要用到 `file_` 的指针，那么此时 `file_` 还是个随机的野指针，一用就崩。

------

## 📜 最终产物：SSTable 物理布局图

现在，你手里的 `.sst` 文件在磁盘上的物理结构如下（这也是你通过 `hexdump` 验证的结果）：

| **区域**         | **结构**               | **作用**                             |
| ---------------- | ---------------------- | ------------------------------------ |
| **Data Block 1** | `[KV][KV]...`          | 存放真正的用户数据                   |
| **Data Block N** | `[KV][KV]...`          | 数据量大时自动切分出的后续块         |
| **Index Block**  | `[LastKey][Handle]...` | **地图**。记录每个 Data Block 的边界 |
| **Footer (24B)** | `[IndexHandle][Magic]` | **罗盘**。文件读取的唯一入口         |

------

## 💡 为什么要这么设计？（408 核心思维）

- **为什么要分 Block？** 为了**局部性原理**。我们不需要为了找一个 Key 就把 1GB 文件全读进内存，只需按需读取 4KB 的页（Page）。
- **为什么要 Footer？** 为了**随机读**。如果不把 Index 的位置放在末尾，我们就必须从头开始扫描文件才能找到索引。现在，只需 `Seek(-24)` 就能直接拿到全局地图。
- **为什么要魔数？** 为了**鲁棒性**。它能确保你的数据库不会试图去解析一个被意外改名的图片或 MP3 文件。