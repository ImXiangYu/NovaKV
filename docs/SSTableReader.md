# SstableReader

### 1. 核心痛点：为什么不直接读取文件？

在 408 操作系统中，传统的读取方式是 `read()` 系统调用。它的流程是：

1. **磁盘 -> 内核缓冲区**（内核态）
2. **内核缓冲区 -> 用户内存**（用户态）

这涉及到 **两次拷贝** 和 **上下文切换**，对于高性能数据库来说太慢了。

因此，我们要引入 **`mmap` (Memory Mapping)**。 **作用：** 它的逻辑是把磁盘上的文件直接“投影”到进程的 **虚拟地址空间**。

- **爽感：** 文件映射完后，你会得到一个 `void* data` 指针。你想读文件内容？直接像操作内存数组一样 `data[100]` 就行了，OS 会自动帮你处理背后的磁盘 I/O。

------

### 2. SstableReader 的“三步走”逻辑

一个 Reader 被创建出来后，它必须按顺序完成三件事，否则它就是个“瞎子”：

#### 第一步：读取 Footer (找罗盘)

Reader 一上来，先根据文件大小，跳到最后 **24 字节**。

- **作用：** 拿到 `Magic Number` 验证身份；拿到 `Index Block` 的位置。
- **如果这一步失败：** 直接报错“文件损坏”。

#### 第二步：读取 Index Block (载入地图)

根据 Footer 提供的偏移量和大小，把 Index Block 读出来。

- **作用：** 解析出所有的 `IndexEntry`。现在 Reader 知道：“Key 从 A 到 M 的在 Block 1，M 到 Z 的在 Block 2”。
- **优化点：** Index Block 通常很小，我们会把它常驻内存。

#### 第三步：按需读取 Data Block (按图索骥)

当用户查询 `Get("Banana")` 时：

1. **查地图：** 在 Index Block 里二分查找，发现 "Banana" 应该在 Block 2。
2. **定位：** 拿出 Block 2 的 `Offset` 和 `Size`。
3. **读取：** 从文件映射的内存里把这 4KB 抠出来，交给 `BlockReader` 去查找具体的 Value。

## Open 在做什么？

之所以 `Open` 看起来复杂，是因为它要处理**底层资源的握手**。我们可以把这 6 个步骤拆解成三个通俗的角色：

------

### 1. 拿钥匙：`open` 与 `fstat`

想象 SSTable 是一个锁着的仓库。

- **`open`**：你向操作系统申请一把钥匙（`fd`，文件描述符）。有了它，你才有权靠近这个仓库。
- **`fstat`**：你量了一下这个仓库有多大（`st_size`）。如果你连仓库有多大都不知道，你后面就没法把它完整地搬进你的脑子（虚拟内存）。

### 2. 搬家（上帝视角）：`mmap`

这是最关键的一步。

- **传统方式 (`read`)**：像搬砖一样，每次只能搬一小块到你家（用户内存），累死累活。
- **`mmap` 方式**：像开了一个“传送门”。你直接把仓库的地面和你的房间地面连在了一起。
- **结果**：你得到了一个指针 `data_`。此时，仓库里的任何一个字节，你通过这个指针都能瞬间摸到。**这就是为什么我们要大费周章调这个系统调用的原因——为了极致的读取性能。**

### 3. 验货（入场检查）：`ReadFooter`

虽然传送门开了，但万一搬错仓库了呢？

- 逻辑很简单：由于仓库大小（`file_size_`）已知，你直接走到仓库的最尽头，抠出最后 24 个字节。
- **魔数校验**：如果是 `0xDEADC0DE...`，说明货对，你可以进场。如果不对，立刻把钥匙还给系统，传送门关掉，交易取消。

### 现在的心理建设

不要被 `POSIX` 的函数名（`open`, `fstat`, `mmap`）吓到。它们本质上就是：

1. **打个招呼** (Open)
2. **量量尺寸** (Stat)
3. **映射内存** (Mmap)
4. **看一眼结尾** (Footer)