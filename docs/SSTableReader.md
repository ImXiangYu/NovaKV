# SstableReader

### 1. 核心痛点：为什么不直接读取文件？

在 408 操作系统中，传统的读取方式是 `read()` 系统调用。它的流程是：

1. **磁盘 -> 内核缓冲区**（内核态）
2. **内核缓冲区 -> 用户内存**（用户态）

这涉及到 **两次拷贝** 和 **上下文切换**，对于高性能数据库来说太慢了。

因此，我们要引入 **`mmap` (Memory Mapping)**。 **作用：** 它的逻辑是把磁盘上的文件直接“投影”到进程的 **虚拟地址空间**。

- **爽感：** 文件映射完后，你会得到一个 `void* data` 指针。你想读文件内容？直接像操作内存数组一样 `data[100]` 就行了，OS 会自动帮你处理背后的磁盘 I/O。

------

### 2. SstableReader 的“三步走”逻辑

一个 Reader 被创建出来后，它必须按顺序完成三件事，否则它就是个“瞎子”：

#### 第一步：读取 Footer (找罗盘)

Reader 一上来，先根据文件大小，跳到最后 **24 字节**。

- **作用：** 拿到 `Magic Number` 验证身份；拿到 `Index Block` 的位置。
- **如果这一步失败：** 直接报错“文件损坏”。

#### 第二步：读取 Index Block (载入地图)

根据 Footer 提供的偏移量和大小，把 Index Block 读出来。

- **作用：** 解析出所有的 `IndexEntry`。现在 Reader 知道：“Key 从 A 到 M 的在 Block 1，M 到 Z 的在 Block 2”。
- **优化点：** Index Block 通常很小，我们会把它常驻内存。

#### 第三步：按需读取 Data Block (按图索骥)

当用户查询 `Get("Banana")` 时：

1. **查地图：** 在 Index Block 里二分查找，发现 "Banana" 应该在 Block 2。
2. **定位：** 拿出 Block 2 的 `Offset` 和 `Size`。
3. **读取：** 从文件映射的内存里把这 4KB 抠出来，交给 `BlockReader` 去查找具体的 Value。