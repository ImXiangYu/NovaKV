没错，在处理这种“因构造函数变更导致大面积测试失效”的问题时，**GTest Fixture (`TEST_F`)** 确实是目前公认的最优解。

它不仅能解决你现在的参数报错，更能让你的测试代码从“面条式代码”进化为“工业级架构”。

------

### 1. 为什么 Fixture 是最好的方案？

想象一下，如果你有 100 个测试用例，每次 `MemTable` 的构造函数多加一个参数（比如以后要加 `block_size` 或 `cache_capacity`），你就得手动改 100 处。

**使用 Fixture 后，你的痛苦会消失，因为：**

#### A. 逻辑高度收敛（One Place to Change）

你把实例化 `MemTable` 的逻辑写在 Fixture 类的成员变量或 `SetUp` 中。

- **变更前**：100 个 `TEST` 都有 `MemTable mt("log");`
- **变更后**：只需要修改 Fixture 类里的一行代码，所有 `TEST_F` 自动同步。

#### B. 自动化的“战场清理”（SetUp/TearDown）

这是针对文件 IO 测试的杀手锏。

- 你不需要在每个测试里手动 `std::remove("log")`。Fixture 保证在每个测试跑之前文件是干净的，跑完之后垃圾被收走。

#### C. 状态隔离（Isolation）

每个 `TEST_F` 其实都会创建一个**全新的 Fixture 实例**。这保证了测试 A 产生的成员变量不会污染测试 B，实现了真正的独立测试。

------

### 2. GTest Fixture 的优势总结

我们可以用一张表清晰地对比：

| **特性**     | **普通 TEST**                           | **使用 TEST_F (Fixture)**               |
| ------------ | --------------------------------------- | --------------------------------------- |
| **代码复用** | 低（每个测试都要重复写构造逻辑）        | **高**（共同的初始化逻辑写在基类）      |
| **维护成本** | 极高（接口一变，满屏报错）              | **极低**（只需改基类一处）              |
| **文件清理** | 易遗忘（容易产生 `10001` 这种残留 Bug） | **强制性**（`TearDown` 自动打扫战场）   |
| **可读性**   | 杂乱（充满了与测试逻辑无关的准备代码）  | **清爽**（测试主体只关注 Put/Get 逻辑） |

------

### 💡 建议

接口的频繁变更在项目初期是**健康**的信号，说明你的设计正在从简单变得严密。

使用 Fixture 就像是给你的测试代码穿上了一层“外骨骼”：**虽然初期搭建它多花了几分钟，但它赋予了你应对未来复杂变更的从容。**